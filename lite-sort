#!/usr/bin/env python3

import argparse, os, sys
from pathlib import Path
from shutil import rmtree

VERSION = "0.1"
PROGNAME = "lite-sort"

DEFAULT_MAX_DEPTH = 4
DEFAULT_CONFIG: dict = {
    # Read files to sort from this
    "file_list": None,
    # Maximum depth to search for files to sort
    "max_depth": DEFAULT_MAX_DEPTH,
    # Start directory to start searching
    "start_dir": Path.cwd(),
    "dest_dir": Path.cwd(),
    # Files to be sorted, will be merged with entries in `file_list`
    "files": [],
}


def main(argv: list[str]) -> None:
    config = DEFAULT_CONFIG

    files_by_type: dict = {
        "archive": [],
        "audio": [],
        "document": [],
        "executable": [],
        "image": [],
        "raw_data": [],
        "video": [],
        "text": [],
    }

    # This will contain all collected files
    file_paths: list[Path] = []

    parse_args(argv, config)

    collect_files(
        start_dir=config["start_dir"],
        current_depth=1,
        config=config,
        file_paths=file_paths,
    )
    sieve_files(config, file_paths, files_by_type)

    cwd = config["start_dir"]
    dest_dir = config["dest_dir"]
    print(str(dest_dir))
    for type, files in files_by_type.items():
        if len(files) > 0:
            resolved_type_dir = dest_dir / type
            if not resolved_type_dir.exists():
                resolved_type_dir.mkdir()

            for f in files:
                dst = dest_dir / type / f.parts[-1]

                if config["verbose"]:
                    print("   %s -> %s" % (str(f), str(dst)))

                os.rename(f, dst)



def sieve_files(config: dict, file_paths: list[Path], files_by_type: dict) -> None:
    # TODO: improve this with the file header especially for files without extension
    # TODO: look into mimetypes
    for f in file_paths:
        match get_ext(f):
            case ".xz" | ".tar" | ".tar.gz" | ".zip" | ".zstd" | ".rar" | ".gz" | ".lzma":
                files_by_type["archive"].append(f)
            case ".mp3" | ".wav" | ".ogg" | ".m4a":
                files_by_type["audio"].append(f)
            case ".docx" | ".doc" | ".xls" | ".ppt" | ".pdf" | ".epub" | ".djvu" | ".mobi" | ".odt" | ".xlsx":
                files_by_type["document"].append(f)
            case ".exe" | ".o" | ".so" | ".a":
                files_by_type["executable"].append(f)
            case ".png" | ".svg" | ".jpg" | ".jpeg" | ".ppm" | ".xpm" | ".gif" | ".tiff" | ".raw":
                files_by_type["image"].append(f)
            case ".iso" | ".data" | ".bin" | ".qcow" | ".qcow2" | ".vdi" | ".vmdk" | ".vhd" | ".hdd":
                files_by_type["raw_data"].append(f)
            case ".mp4" | ".mkv" | ".mov" | ".avi" | ".3gp" | ".webm" | ".m4v":
                files_by_type["video"].append(f)
            case _:
                files_by_type["text"].append(f)


def get_ext(path: Path) -> str:
    return "".join(path.suffixes)


def collect_files(start_dir: Path, current_depth: int, config: dict, file_paths: list[Path]) -> None:
    """
    Walk the path (which is a directory), and collect any files in it into `file_paths`.
    It enumerates `start_dir` on each call.
    """

    if current_depth > config["max_depth"]:
        return

    # enumerate the current directory
    next_ = next(start_dir.walk(top_down=True, follow_symlinks=False, on_error=print))
    if not next_:
        return

    root, dirs, files = next_

    # collect the (toplevel) regular files here
    for f in files:
        fp = root / f
        if fp.is_file():
            if fp.name in config["files"]:
                print("found: %s" % str(fp))
                file_paths.append(fp)
    del files

    # deal with the subdirectories
    for dir in dirs:
        if not Path(dir).stem.startswith("."):
            collect_files(root / dir, current_depth + 1, config, file_paths)
    del dirs


def parse_args(argv: list[str], config: dict) -> None:
    parser = argparse.ArgumentParser(
        prog=PROGNAME,
        description="Collect and sort files in a given directory into directories matching (or relevant to) their filetype.",
        epilog="",
    )
    parser.add_argument(
        "files",
        metavar="FILES",
        help="Files to sort. With no files provided, sorts files starting from the current directory and its subdirectories.",
        nargs="*",
        type=str,
    )
    parser.add_argument(
        "-s",
        "--start-dir",
        metavar="START_DIR",
        help="start directory, where files to be sorted are searched",
        type=str,
    )
    parser.add_argument(
        "-d",
        "--dest-dir",
        metavar="DEST_DIR",
        help="destination directory, where files to be sorted are moved to",
        type=str,
    )
    parser.add_argument(
        "-D",
        "--max-depth",
        metavar="MAX_DEPTH",
        help="maximum filesystem directory depth to search for files",
        type=int,
    )
    parser.add_argument(
        "-f",
        "--file-list",
        metavar="FILE",
        help="file containing list of files to be sorted, files in this list will be merged\n\
              with the [FILES] passed as arguments\n",
        type=str,
    )
    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version=PROGNAME + " " + VERSION,
    )

    args = parser.parse_args(argv)

    if args.file_list:
        config["file_list"] = Path(args.file_list)

    if args.max_depth:
        config["max_depth"] = args.max_depth

    if args.start_dir:
        dir = Path(args.start_dir)
        if dir.exists():
            config["start_dir"] = dir.absolute()
        else:
            print("%s: error: directory '%s' doesn't exist." % (PROGNAME, str(dir)), file=sys.stderr)
            exit(1)
    if args.dest_dir:
        dir = Path(args.dest_dir)
        if dir.exists():
            config["dest_dir"] = dir.absolute()
        else:
            print("%s: error: directory '%s' doesn't exist." % (PROGNAME, str(dir)), file=sys.stderr)
            exit(1)

    if len(args.files) > 0:
        config["files"].extend(args.files)

    if config["file_list"]:
        merge_filelist(config)


def merge_filelist(config: dict) -> None:
    """Assumes files are in the current directory or its children."""
    with open(config["file_list"], "r") as file_list:
        files_from_list = list(map(lambda line: line.strip(), file_list.readlines()))
        config["files"].extend(files_from_list)


def prep_test_args(argv: list[str]) -> None:
    for f in argv:
        p = Path(f).absolute()
        if not p.exists():
            if p.is_dir():
                p.mkdir(parents=True)
            else:
                if not p.parent.exists():
                    p.parent.mkdir(parents=True)
                p.touch()
        else:
            p.mkdir(parents=True) if p.is_dir() else p.touch()


def clean_test_args(argv: list[str]) -> None:
    # TODO: Implement using os.walk()
    for f in argv:
        p = Path(f)
        if p.exists():
            if p.is_file():
                p.unlink()
                rmtree(p.parts[0])
            else:
                rmtree(p)

    print("\nCleaned generated directories")


test = False
test_argv = [
    "test",
    "file1.txt",
    "file2.pdf",
    "file3.zip",
    "dir1/d/d/d/d/d/d/d//file4.xz",
    "dir2/dir21/dir211/dir2111/dir21111/not_a_dir",
]

# TODO: implement proper testing

if __name__ == "__main__":
    argv = test_argv if test else sys.argv

    prep_test_args(test_argv[1:]) if test else None

    # ignore the first argument
    main(argv[1:])

    # clean_test_args(test_argv[1:]) if test else None
