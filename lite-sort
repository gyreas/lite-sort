#!/usr/bin/env python3

import sys, os
from pathlib import Path


DEFAULT_MAX_DEPTH = 4
DEFAULT_CONFIG: dict = {
    # Read files to sort from this
    "file_list": None,
    # Maximum depth to search for files to sort
    "max_depth": DEFAULT_MAX_DEPTH,
    # Start directory to start searching
    "start_dir": Path.cwd(),
    # Files to be sorted, will be merged with entries in `file_list`
    "files": [],
}


def main(argv: list[str]) -> None:
    config = DEFAULT_CONFIG

    files_by_type: dict = {
        "archive": [],
        "audio": [],
        "document": [],
        "executable": [],
        "image": [],
        "raw_data": [],
        "video": [],
        "text": [],
    }

    # This will contain all collected files
    file_paths: list[Path] = []

    parse_args(argv, config)
    collect_files(
        start_dir=config["start_dir"],
        current_depth=1,
        max_depth=config["max_depth"],
        file_paths=file_paths,
    )
    sieve_files(config, file_paths, files_by_type)

    cwd = config["start_dir"]
    print(str(cwd))
    for type, files in files_by_type.items():
        if len(files) > 0:
            resolved_type_dir = cwd / type
            if not resolved_type_dir.exists():
                resolved_type_dir.mkdir()

            for f in files:
                os.rename(f, cwd / type / f.parts[-1])
            print("  \\_ %s" % type)


def sieve_files(config: dict, file_paths: list[Path], files_by_type: dict) -> None:
    # TODO: improve this with the file header especially for files without extension
    # TODO: look into mimetypes
    for f in file_paths:
        if f.name in config["files"]:
            match get_ext(f):
                case ".xz" | ".tar" | ".tar.gz" | ".zip" | ".zstd" | ".rar" | ".gz" | ".lzma":
                    files_by_type["archive"].append(f)
                case ".mp3" | ".wav" | ".ogg" | ".m4a":
                    files_by_type["audio"].append(f)
                case ".docx" | ".doc" | ".xls" | ".ppt" | ".pdf" | ".epub" | ".djvu" | ".mobi" | ".odt" | ".xlsx":
                    files_by_type["document"].append(f)
                case ".exe" | ".o" | ".so" | ".a":
                    files_by_type["executable"].append(f)
                case ".png" | ".svg" | ".jpg" | ".jpeg" | ".ppm" | ".xpm" | ".gif" | ".tiff" | ".raw":
                    files_by_type["image"].append(f)
                case ".iso" | ".data" | ".bin" | ".qcow" | ".qcow2" | ".vdi" | ".vmdk" | ".vhd" | ".hdd":
                    files_by_type["raw_data"].append(f)
                case ".mp4" | ".mkv" | ".mov" | ".avi" | ".3gp" | ".webm" | ".m4v":
                    files_by_type["video"].append(f)
                case _:
                    files_by_type["text"].append(f)


def get_ext(path: Path) -> str:
    return "".join(path.suffixes)


def collect_files(start_dir: Path, current_depth: int, max_depth: int, file_paths: list[Path]) -> None:
    """
    Walk the path (which is a directory), and collect any files in it into `file_paths`.
    It enumerates `start_dir` on each call.
    """

    if current_depth > max_depth:
        return

    # enumerate the current directory
    next_ = next(start_dir.walk(top_down=True, follow_symlinks=False, on_error=print))
    if not next_:
        return

    root, dirs, files = next_

    # collect the (toplevel) regular files here
    for f in files:
        fp = root / f
        if fp.is_file():
            file_paths.append(fp)
    del files

    # deal with the subdirectories
    for dir in dirs:
        if not Path(dir).stem.startswith("."):
            collect_files(root / dir, current_depth + 1, max_depth, file_paths)
    del dirs


def usage(arg0: str = "lite-sort") -> None:
    usage = """\
Usage: %s [options] [files]

With no files provided, sorts files starting from the current directory and its subdirectories.

-d, --start-dir   start directory, where files to be sorted are searched
-D, --max-depth   maximum filesystem directory depth to search for files
-f, --file-list   file containing list of files to be sorted, files in this
                  list will be merged with the [files] passed as arguments
-h, --help        display this help and exit
-v, --version     output version information and exit
"""
    print(usage % arg0, file=sys.stderr)


def parse_args(argv: list[str], config: dict) -> None:
    # TODO use `argparse`
    argc = len(argv)

    # regular operations
    i = 1
    while i < argc:
        arg = argv[i]

        if arg == "-h" or arg == "--help":
            usage(argv[0])
            exit(0)
        elif arg == "-f" or arg == "--file-list":
            if i + 1 == argc:
                print("lite-sort: --file-list: no file provided", file=sys.stderr)
                usage(argv[0])
                exit(1)
            if argv[i + 1] == "-h" or argv[i + 1] == "--help":
                usage(argv[0])
                exit(1)
            elif argv[i + 1] == "-D" or argv[i + 1] == "--max-depth":
                usage(argv[0])
                exit(1)

            config["file_list"] = Path(argv[i + 1])

            i += 1
        elif arg == "-d" or arg == "--start-dir":
            dir = Path(arg)
            if dir.exists():
                config["start_dir"] = dir.absolute()
            else:
                print("directory '%(dir)s' doesn't exist." % {"dir": str(dir)}, file=sys.stderr)
        elif arg == "-D" or arg == "--max-depth":
            pass
        else:
            # no other arguments supported, collect the rest as files to sort
            config["files"].extend(argv[i:])
            break

        i += 1

    if config["file_list"]:
        merge_filelist(config)


def merge_filelist(config: dict) -> None:
    """Assumes files are in the current directory or its children."""
    with open(config["file_list"], "r") as file_list:
        files_from_list = list(map(lambda line: line.strip(), file_list.readlines()))
        config["files"].extend(files_from_list)


def prep_test_args(argv: list[str]) -> None:
    for f in argv:
        p = Path(f)
        if not p.exists():
            ps = f.split("/")
            if len(ps) > 1:
                maybe_f = Path(ps[-1])
                dirs = Path("/".join(ps[:-1]))
                dirs.mkdir(parents=True)
                if maybe_f.is_dir():
                    (dirs / maybe_f).mkdir()
                else:
                    (dirs / maybe_f).touch()
            else:
                p.mkdir() if p.is_dir() else p.touch()


def clean_test_args(argv: list[str]) -> None:
    # TODO: Implement using os.walk()
    for f in argv:
        p = Path(f)
        if p.exists():
            dirs = f.split("/")
            if len(dirs) > 1:
                if p.is_file():
                    p.unlink()
                    dirs.pop()
                for i in range(0, len(dirs)):
                    Path("/".join(dirs)).rmdir()
                    dirs.pop()
            else:
                p.rmdir() if p.is_dir() else p.unlink()


test = False
test_argv = [
    "test",
    "file1.txt",
    "file2.pdf",
    "file3.zip",
    "dir1/d/d/d/d/d/d/d//file4.xz",
    "dir2/dir21/dir211/dir2111/dir21111/not_a_dir",
]

# TODO: implement proper testing

if __name__ == "__main__":
    argv = test_argv if test else sys.argv

    prep_test_args(test_argv[1:]) if test else None

    main(argv)

    # clean_test_args(test_argv[1:]) if test else None
